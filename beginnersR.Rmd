---
title: "biginnersR"
output: html_document
---

R은 근래 데이터 분석 분야에서 널리 사용되고 있는 통계 분석 솔루션이자 프로그래밍 언어입니다. 이번 워크샵은 R을 사용해서 텍스트 데이터를 처리하고, 이를 바탕으로 단어와 단어 사이의 공출현 빈도를 측정한 다음 이를 의미연결망 네트워크로 만드는 것까지 진행할 예정입니다. 시간이 제한되어 있는 관계로, R의 기초만 간단하게 다룬 다음에 바로 의미연결망 분석에 필요한 단계로 넘어가도록 하겠습니다.

이번 강의에 사용되는 프로그램은 RStudio로, 프로그래밍 언어 R을 유저가 좀 더 사용하기 편하고 작업 효율을 올려줄 수 있도록 만들어진 Integrated Development Environment(IDE)입니다. 여러분이 보고 계신 글이 쓰여져 있는 공간은 '에디터'라고 불리며, 코드를 작성하고 수정하며 한 눈에 볼 수 있게 만들어진 공간입니다. 그 아래에 있는 것은 '콘솔'인데, 실행한 코드와 함께 그 결과물이 출력되는 공간입니다. 에디터에 입력한 코드를 드래그해서 선택한 다음, Ctrl+Enter/R 을 해주면 에디터의 코드가 그대로 콘솔에서 실행되는 것을 알 수 있습니다. 예를 들어 a라는 변수에 "hello world"라는 문자열을 할당하고, 이를 콘솔에 출력하는 코드를 짜서 실행해 봅시다.

a="hello world"
a
print(a)

이를 실행하면 콘솔 화면에 코드가 그대로 실행되고, "hello world"라는 문자열이 출력된 것을 알 수 있습니다. 변수로 할당된 데이터의 경우 굳이 print 명령어를 입력하지 않아도 그대로 출력되는 것을 알 수 있습니다. 

오른쪽을 보도록 합시다. Environment라는 패널이 있고, 그 아래의 values라는 항목에 변수 a와 그 a에 할당된 "hello world"라는 문자열을 확인할 수 있습니다. 이는 현재 프로그램 내에 할당된 변수와 함수 등을 유저가 쉽게 찾아보고 살펴볼 수 있도록 해 주는 패널입니다. 

그 아래를 살펴보면 Files라는 패널이 있습니다. 말 그대로 파일을 다룰 수 있는 패널인데, 작업 디렉토리인 kdiworkshop2016과 그 하위 폴더인 Script, Result, Data가 보입니다. 각각을 클릭해서 안에 있는 파일을 살펴보고, 스크립트의 경우 에디터로 그대로 띄워서 살펴볼 수도 있습니다.

다만 이번 워크샵에서는 RMarkdown이라는 형태의 문서 작성 툴을 활용해 진행하려 합니다. RMD를 사용하면 굳이 콘솔 없이도 직접 코드를 작성하고 바로바로 그 실행 결과를 확인할 수 있습니다. RMD에서 코드를 입력하고 실행하기 위해서는 Chunk를 만들어야 합니다. 키보드의 esc키 아래에 있는 `를 세 번 입력하고 뒤에 {r}을 붙이면 chunk가 생기며 이를 닫아줄 때에는 다시 세 번 입력하면 됩니다. 아니면 에디터 위쪽 상단의 Insert를 눌러서 R을 선택해도 됩니다.

예를 들어서 다음 예시를 통해 방금 실행해 본 변수 할당과 출력을 실험해 보도록 합시다. chunk에 있는 코드를 실행하려면 오른쪽의 녹색 화살표를 누르거나, Ctrl+Alt+C를 누르면 됩니다.

```{r}
a="hello world"
a
print(a)
```

chunk의 아래에 결과값 출력을 위한 공간이 생기고, 여기에 결과값이 그대로 출력되는 것을 알 수 있습니다. RMD를 사용하면 굳이 콘솔이 필요하지 않으므로, 콘솔 창의 상단부를 드래그해서 내린 다음 에디터만 가지고 워크샵을 진행하도록 하겠습니다. 다음은 R의 데이터 타입에 대해서 설명해 드리도록 하겠습니다. 


Scalar & Vector

위에서 a에 hello world라는 문자열을 할당했던 것처럼, R에서는 숫자나 문자열, 불리언(True/False)등의 데이터를 변수에 할당할 수 있습니다. 

```{r}
a=5
b="I like R"
c=TRUE

a
b
c
```

문자열 데이터의 경우 반드시 작은 따옴표나 큰 따옴표를 붙여야 합니다. 변수에 이러한 데이터를 여러 개 할당할 때에는 '벡터'라는 가장 기초적인 데이터 타입을 사용할 수 있습니다. 벡터 형식으로 변수를 할당할 때에는 c()라는 형식으로 묶어 줘야 합니다. 이렇게 벡터 안에 들어간 데이터들은 대괄호 안에 숫자를 붙임으로써 호출할 수 있습니다. 하나만을 호출할 경우엔 숫자를 넣어주고, 특정한 범위로 불러올 때에는 콜론을 사용해 범위를 설정합니다. 한 변수에 저장된 여러 데이터 가운데 특정 요소만 빼고 불러오려 할 경우 그 순서의 숫자에 -를 붙이며, 범위를 설정할 경우에도 가능합니다.

```{r}
a <- c(1,2,5.3,6,-2,4) # numeric vector
b <- c("one","two","three") # character vector
c <- c(TRUE,TRUE,TRUE,FALSE,TRUE,FALSE) #logical vector

a
b
c

a[1]
b[1:3]
c[-1:-3]
```

이러한 단순한 형태의 데이터가 아니라 설문지 데이터와 같은 구조화된 자료를 다루기 위한 데이터 타입으로는 데이터 프레임이 있습니다. 

```{r}
d <- c(1,2,3,4)
e <- c("red", "white", "red", NA)
f <- c(TRUE,TRUE,TRUE,FALSE)
df <- data.frame(d,e,f)

print(df)
```

4*3 행렬 형식의 표가 만들어지며, 각각의 행과 열 안에는 다른 타입의 데이터를 포함시킬 수 있습니다. 

```{r}
names(df)=c("numeric","character","bool")

df$numeric
df[1]
df[[1]]
df[1,]
df[1,3]
df[1:2]
```

행마다 이름을 지정해 주려면 names라는 함수를 사용하면 되며, 이렇게 이름을 지정하면 데이터 프레임 변수 뒤에 $를 붙이고 행 이름을 지정해서 그대로 불러올 수 있습니다. 대괄호 안에 여러 가지 숫자를 넣어서 특정 셀의 데이터를 불러오거나 행, 열, 혹은 범위를 지정해서 불러오는 것 역시 가능합니다. 다만 행 이름을 지정해서 불러오거나 대괄호를 두 번 쓰는 경우(벡터로 변환)를 제외하면 모두 데이터 프레임 형식을 유지하고 있습니다.

데이터 프레임은 장점이 많고 다루기 편리하지면 n*m 표의 개별 셀에는 하나의 데이터만을 집어넣을 수 있으며, 결과적으로 길이가 다른 데이터를 다루기에는 무리가 있습니다. 그래서 온갖 종류의 데이터를 다 넣거나 길이가 애매한 경우 리스트를 씁니다.

```{r}
w <- list(name="Kim", mynumbers=a, mymatrix=df, bool=c)
w
w$name
w[[1]]
w[1]
w[[3]][1:3,2:3]
```

RMD의 결과창에는 잘려서 나오지만, 실제로 4가지 다른 타입의 데이터(문자열 스칼라, 숫자 벡터, 데이터 프레임, 불리언 벡터)가 각각 잘 저장되었음을 확인할 수 있습니다. 이를 호출할 때에는 데이터 프레임과 같은 방식을 사용하면 됩니다. 마지막 예시의 경우 변수 df가 저장된 세 번째 구간을 불러오고, df에 대해서 대괄호를 사용해 그 안의 데이터를 불러온 것입니다. 

마지막으로 반복문을 살펴보아야 합니다. 반복문은 말 그대로 반복적인 명령어를 수행하게 해 주는 것인데요, R의 반복문은 다음과 같은 구조를 갖고 있습니다.

```{r}
for(i in 1:10){
  print(i)
}
a <- c("one","two","three")
for(i in b){
  print(i)
}
```

(i in 1:10)의 경우 반복문을 수행할 때 활용하는 데이터로, 일정한 길이를 가진 변수를 뒤 쪽에 입력하면 그 변수의 값이 하나씩 순서대로 i라는 변수에 할당되어 반복문 속에서 변수로 작동하게 됩니다. 위의 예제의 경우 1:10이라는 숫자 벡터와 "one","two","three"라는 문자열 벡터가 for문 속에서 i변수에 할당되어 출력된 것을 알 수 있습니다. 그 다음으로는 조건문을 살펴보겠습니다.


```{r}
if(a[1]=="two"){
  print("TRUE")
} else{
  print("FALSE")
}
```

조건문은 괄호 안에 있는 문장이 참일 경우에 중괄호 안의 명령어를 실행하는 형식입니다. 위의 예시에서는 a[1]에 있는 데이터는 "two"가 아니라 "one"이기 때문에 a[1]=="two"라는 조건은 거짓이며, 따라서 if문 뒤의 중괄호에 있는 "TRUE"가 아니라 그것이 틀릴 경우에 실행되는 else 뒤의 괄호가 출력되었습니다.

이제 바로 데이터 분석 단계로 넘어가도록 하겠습니다. 오른쪽 파일 패널에서 preprocess.Rmd를 열어주세요. 
